# Sync

Архив системы. Последний релиз: `25-10-2008`.

## Состав системы

Все необходимые файлы и каталоги размещаются в домашнем каталоге
пользователя `sync`.

* `archive` - команда архивирования пакетов
* `syncctl` - программа синхронизации
* `nodeconf` - скрипт получения информации об узлах из конф. файла
* `etc/sync.conf` - конфигурационный файл системы синхронизации
* `etc/nodes.conf` - конфигурационный файл удаленных узлов
* `etc/nodes.sec`- конфигурационный файл уровней безопасности пакетов
* `etc/common` - общие параметры, процедуры и функции
* `etc/sybase.sql` - все SQL-выражения, используемые в системе
* `etc/profiles` - файлы-шаблоны для трех профилей системы:
  * `azs` - для использования системы на АЗС
  * `office` - для использования системы в оперцентре
  * `center` - для использования системы в клиринговом центре
* `doc` - документация по проекту
  * `Формат пакета.pdf`
  * `Система шифрования пакетов.pdf`
  * [`changelog.txt`](doc/changelog.txt) - история изменений системы
  * [`doc/todo.txt`](doc/todo.txt) - список будущих изменений системы

В базу данных устанавливается система под пользователем, который
устанавливает соединение с БД в программе, указанной в `SQL_EXEC`.

## Список используемых системных утилит

* awk
* cat
* cksum
* expr
* gpg
* gzip
* printf
* sed
* sort
* tar
* touch
* tr
* zcat

## Дерево каталогов

```
   /home/sync/          - домашний каталог системы
       nodes/           - общий каталог для данных всех удаленных узлов
           node1/       - данные, относящиеся к удаленному узлу node1
               inbox/   - входящие сообщения (что пришло с узла)
               outbox/  - исходящие сообщения (что должно уйти на узел)
           node2/
               inbox/
               outbox/
           ...
        arch/               - архив пакетов
               inbox/       - для входящих пакетов
                 node1/     - пакеты, пришедшие с удаленного узла node1
                   YYYY.MM/   Пакеты разносятся по разным каталогам,
                 node2/       в зависимости от даты обработки пакетов.
                   YYYY.MM/
                 ...
               outbox/      - для исходящих пакетов
                 node1/     - пакеты, пришедшие с удаленного узла node1
                   YYYY.MM/   Пакеты разносятся по разным каталогам,
                 node2/       в зависимости от даты создания пакетов.
                   YYYY.MM/
                 ...
```

Например, если имеются два узла `barnaul` и `azs1`, которые взаимно
обмениваются информацией, то потоки информации между каталогами
можно отобразить следующим образом:

```
          Узел barnaul      |           Узел azs1
 ---------------------------|--------------------------------
   /home/sync/              |                    /home/sync/
     nodes/                 |                  nodes/
       azs1/                |              barnaul/
 ------  inbox/    <----- пакеты -----    outbox/ -------
 | ----  outbox/    ----- пакеты ----->   inbox/  ----- |
 | |                        |                         | |
 | | arch/                  |                  arch/  | |
 | |   inbox/               |               inbox/    | |
 | |     azs1/              |            barnaul/     | |
 |-------> 2003.04/         |          2003.04/ <-----| |
   |   outbox/              |               outbox/     |
   |     azs1/              |            barnaul/       |
   |-----> 2003.04/         |          2003.04/ <-------|
```

## Содержимое каталога определенного узла

```
     node1/
         .connect            - параметры соединения с узлом
         .prepare.sql        - закэшированный SQL-скрипт подготовки
                               данных для узла
         .update.sql         - закэшированный SQL-скрипт обработки
                               данных с узла
         inbox/
             pkt-0000001.tgz - файлы-пакеты, пришедшие с удаленного узла
             pkt-0000002.tgz   и еще не обработанные
         outbox/
             pkt-0000001.tgz - файлы-пакеты, сформированные для отправки
                               на удаленный узел, но еще не отправленные
```

## Содержимое файла-пакета

```
 ----------------------------------------------------------------
                    Уровень безопасности пакета
 ----------------------------------------------------------------
          0           |          1          |          2
 ----------------------------------------------------------------
 пакет без защиты     | подписанный пакет   | зашифрованный пакет
 ----------------------------------------------------------------
 packet.info            packet.info           packet.info
 Owner_TableName1.dat   packet.info.sig       packet.info.sig
 Owner_TableName1.del   packet.data           packet.data.enc
 Owner_TableName2.dat   packet.data.sig       packet.data.sig
 Owner_TableName2.del

 packet.info      - Служебная информация о пакете
 packet.info.sig  - Подпись файла packet.info
 packet.data      - Данные пакета
 packet.data.enc  - Данные пакета в зашифрованном виде
 packet.data.sig  - Подпись файла packet.data

 Содержимое файла packet.data (файл в формате tgz):

   Owner_TableName1.dat - Добавленные и измененные записи таблицы TableName1
   Owner_TableName1.del - Стертые записи из таблицы TableName1
   Owner_TableName2.dat - Добавленные и измененные записи таблицы TableName2
   Owner_TableName2.del - Стертые записи из таблицы TableName2
   ....
```

## Шаги по установке

1. Распаковать инсталляционый файл при помощи команды
     `$ zcat sync.tgz | tar x`

1. Добавить пользователя `sync` в `/etc/passwd`:
     `sync::3:3:Synchronization System:/home/sync:/bin/sh`

1. Добавить группу `sync` в `/etc/group`:
     `sync::3:sync`

1. Определить имя локального узла (значение переменной `NODENAME` в
   `etc/sync.conf`)

1. Установить систему в базе данных (будут созданы служебные таблицы):
     `$ syncctl system install`

1. Добавить в систему удаленные узлы:
     `$ syncctl node add <имя удаленного узла>`

1. Указать записи каких таблиц будут тиражироваться на удаленные узлы:
     `$ syncctl table add <имя таблицы>`

1. Указать индивидуально для каждого узла какие таблицы и с какими
   ограничениями будут тиражироваться на удаленные узлы:
     см. описание в файле `nodeconf`

## Ограничения системы и налагаемые условия на среду выполнения

* Система не будет замечать изменения в записях, если при этом прямо
  модифицируется значение служебного поля `Packet` или `InitPacket`.

* Система не будет замечать удаления записей, если значение служебного
  поля `InitPacket` равно `0`.

* Система при синхронизации оперирует только общими полями, входящими
  в таблицу на обеих сторонах. Существует несколько ограничений этого
  правила:

  * Ключевые поля таблицы на принимающей стороне должны обязательно
    присутствовать в таблице на отсылаемой стороне (не обязательно,
    как ключевые и не обязательно как реальные).

  * Не могут синхронизироваться таблицы, состоящие только из
    ключевых полей.

  * Не могут синхронизироваться таблицы, в которых есть поля типов
    `long varchar` и `long binary`. Это связано с тем, что в их
    именах используется пробел. Также неопределено поведение системы
    в случае наличия полей типа `user-defined`.

* У синхронизируемой таблицы должен обязательно определен первичный
  ключ, причем на обеих сторонах обмена.

* Система должна работать на том компьютере, на котором запущен
  сервер баз данных, если это SQL Anywhere. Это связано с
  особенностью реализации обновления данных: используется
  команда `load`, которая требует нахождения файлов данных
  на компьютере, где запущен `db engine`.

* Система должна устанавливаться в базу данных только под одним
  пользователем.

* Предполагается, что программа `$SQL_EXEC` возвращает код возврата,
  указывающий на успешность выполнения SQL-выражения.

* Предполагается уникальность имени служебного поля `Packet` во
  всех таблицах базы данных. Другими словами, если у таблицы
  имеется поле `Packet`, то однозначно предполагается, что данные
  этой таблицы тиражируются на удаленные узлы.

* Служебными полями считаются поля, названия которых начинается с `pkt_`.

* Имя удаленного узла не может содержать пробелов и знаков подчеркивания.

* Имя удаленного узла не может быть `default`, так как это ключевое
  слово используется в конфигурационном файле `nodes.sec`.

* Имя владельца таблицы не может содержать символ `_`.

## Встраивание системы синхронизации в дистрибутив АЗС

Для того, чтобы встроить систему синхронизации в дистрибутив станции
необходимо выполнить команду `build_from_cvs` из каталога `etc/profiles`.
При этом файлы системы будут извлекаться непосредственно из CVS.

```
  $ build_from_cvs <dir> <version>

  где <dir>     - корневой каталог дистрибутива станции. Обычно
                  это каталог, куда смонтирован раздел 77 диcтри-
                  бутивного диска. Система будет установлена
                  в каталог /home/sync на этом разделе;
      <version> - официальная метка версии системы в CVS (обычно
                  RELEASE-X_Y_Z, см. раздел ВЕРСИИ СИСТЕМЫ)
```

## Версии системы

Для подробного описания изменений см. файл [doc/changelog.txt](doc/changelog.txt)

* RELEASE-2_1
* RELEASE-2_1_1
* RELEASE-3_0
* RELEASE-3_1
* RELEASE-3_2

## Использование системы

### Утилита `syncctl`

`$ syncctl <объект> <действие> [<опции>]`

#### Объекты

| Объект | Описание |
| --- | --- |
| `system` | система синхронизации в целом |
| `keyring` | ключи системы |
| `node` | удаленный узел (узел, который будет получать данные) |
| `table` | синхронизируемая таблица |
| `data` | данные синхронизации |
| `prepared` | номер последнего успешно сформированного пакета |
| `updated` | номер последнего успешно обработанного пакета |

#### Действия над объектом `system`

| Действие | Описание |
| --- | --- |
| `install` | установить систему в базе данных |
| `uninstall` | убрать из базы все, что относится к системе |
| `update` | обновить систему в базе данных |
| `status` | вывести данные о системе (версия, узлы, таблицы) |
| `reset-cache` | сбросить все кэшированные SQL-скрипты |

#### Действия над объектом `keyring`

| Действие | Описание |
| --- | --- |
| `make` | создать первичную пару ключей для данного узла |
| `make for <узел>` | создать первичную пару ключей для узла `<узел>` |
| `add <узел>.key` | добавить открытый ключ узла в кольцо доверия |
| `remove <узел>` | удалить открытый ключ узла из кольца доверия |
| `list` | вывести список открытых ключей |
| `export` | выгрузить свой открытый ключ в файл `<узел>.key` |

#### Действия над объектом `node`

| Действие | Описание |
| --- | --- |
| `add <название узла>` | добавить узел в систему |
| `remove <название узла>` | убрать узел из системы |
| `reset <название узла>` | начать заново формирование исходящих пакетов |
| `list` | вывести список узлов, зарегистрированных в системе |

#### Действия над объектом `table`

| Действие | Описание |
| --- | --- |
| `add <имя таблицы>` | сделать записи таблицы тиражируемые на узлы  |
| `update <имя таблицы>` | обновить метаданные таблицы для тиражирования |
| `remove <имя таблицы>` | прекратить тиражировать записи таблицы |
| `dwatch-on <имя таблицы>` | включить слежение за удалением записей таблицы |
| `dwatch-off <имя таблицы>` | выключить слежение за удалением записей таблицы |

#### Действия над объектом `data`

| Действие | Описание |
| --- | --- |
| `prepare [for <group>]` | подготовить данные для отправки на узел/узлы |
| `update from <group>` | обновить БД данными, пришедшими с узла/узлов, где `<group>` - название группы узлов или конкретного узла |

#### Действия над объектом `prepared`

| Действие | Описание |
| --- | --- |
| `get for <node>` | вернуть номер последнего успешно сформированного пакета |
| `set <num> for <node>` | установить номер последнего успешно сформированного пакета |

#### Действия над объектом `updated`

| Действие | Описание |
| --- | --- |
| `get for <node>` | вернуть номер последнего успешно обработанного пакета |
| `set <num> for <node>` | установить номер последнего успешно обработанного пакета |

### Утилита `nodeconf`

Получить информацию по узлу или группе узлов из конфигурационного файла узлов

`nodeconf <узел/группа> <объект> [for <таблица>]`

#### Объекты

| Объект | Описание |
| --- | --- |
| `nodelist` | список узлов, входящих в группу. Если в качестве первого параметра задан узел, то он и будет возращен |
| `grouplist` | список групп, в которые входит узел |
| `tablelist` | список таблиц, данные которых передаются на узел |
| `fieldlist` | список полей таблицы |
| `condition` | условие для выборки данных из таблицы |
| `tablealias` | другое имя таблицы, если оно определено. Иначе это же имя. |
| `config` | текущая конфигурация узла |

## Формат конфигурационного файла

В файле индивидуально для узла или для группы узлов прописываются
параметры, влияющие на процесс генерации данных:

1. набор таблиц, данные которых будут пересылаться на узел;
1. индивидуально для каждой таблицы:
    * вертикальная фильтрация - набор полей таблицы;
    * горизонтальная фильтрация - условия, налагаемые на каждую запись таблицы.

Файл разбит на секции двух типов:

* необязательная секция для описания групп узлов, и
* одна или более секций для описания параметров узлов.

Секция начинается с заголовка секции и заканчивается
обязательным признаком конца секции.

Признак конца секции должен присутствовать, даже если
в файле определяется только одна секция или секция
располагается в конце файла.

### Секция *Группы узлов*

Секция содержит описание одной или более групп узлов.
Файл может содержать только одну секцию данного типа.

* Заголовок секции: `# === Groups ===`
* Признак конца секции: `# ==============`

Формат для определения группы:

  `group_<название группы>="<узел|группа>[ <узел|группа>...]"`

Группы могут быть вложенными.

ВНИМАНИЕ! Название группы не должно быть частью названий узлов.
Например, группа `azs` и узлы `azs1`, `azs2` и т.д. Смените в таком
случае название группы, напрмер, на `azses`.

### Секция *Параметры узлов*

Секция содержит описание параметров для узлов, указанных
в заголовке секции. Файл может содержать несколько секций
для одного узла.

* Заголовок секции: `# === For nodes: <узел|группа>[ <узел|группа>...]`
* Признак конца секции: `# ==============`

#### Формат для определения таблиц и их полей

Все поля таблицы плюс необязательные *виртуальные* поля:

  `table_<владелец>_<таблица>='*[ <вирт.поле1>...]'`

Указанные поля (в том числе *виртуальные*) плюс поля, входящие в первичный ключ:

  `table_<владелец>_<таблица>='<поле1>[ <поле2>...]'`

Формат определения *виртуального* поля: `<имя>[<тип>]=<значение>`

* `<имя>` - название поля,
* `<тип>` - SQL-тип поля,
* `<значение>` - любое допустимое SQL-выражение с одним исключением: выражение не должно содержать пробелов!

Виртуальное поле может "перекрывать" собой любое поле в таблице, в том
числе входящее в первичный ключ.

#### Формат для определения дополнительных условий по выборке данных из таблиц

  `condi_<владелец>_<таблица>="<условие>"`

В условии и в списке полей могут использоваться специальные
макропеременные, значения которых подставляются во время
выполнения команды `syncctl data prepare`:

* `<sender_name>` - имя узла, который готовит пакет
* `<receiver_name>` - имя узла, для которого готовится пакет
* `<sender_number>` - число, входящее в `<sender_name>` (например, для узла `azs99` `<sender_number>` заменяется на `99`)
* `<receiver_number>` - число, входящее в `<receiver_name>` (например, для узла `azs99` `<receiver_number>` заменяется на `99`)

#### Определение представлений (view)

Для включения представления в процесс синхронизации необходимо:

1. включить каждую таблицу, входящую в представление в процесс
   синхронизации командой `syncctl table add <владелец>.<таблица>`

1. переопределить представление таким образом, чтобы в него вошли
   все поля `Packet` от таблиц, входящих в представление:

  ```
  create view as select <поля>,
                        <таблица1>.Packet as pkt_<таблица1>,
                        <таблица2>.Packet as pkt_<таблица2>,
                        ...
                   from <таблица1>,
                        <таблица2>,
                        ...
                  where <условие>
  ```

1. добавить представление в файл `nodes.conf` как обычную таблицу с двумя исключениями:

  * в списке полей нельзя использовать знак `*` (все поля);
  * в списке полей обязательно должен быть определен список полей, входящих в "виртуальный" первичный ключ представления, путем заключения этих полей в фигурные скобки `{}`

  ```
  table_<владелец>_<представление>='{<ключ.поле1> <ключ.поле2>...}[ <поля>]'
  condi_<владелец>_<представление>="<условие>"
  ```

#### Переименование таблиц и представлений

  `alias_<владелец>_<таблица>="<НОВЫЙ владелец>.<НОВОЕ название таблицы>"`
