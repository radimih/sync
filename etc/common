######################################################################
# Autor: Радимир Михайлов (radimir@mobilcard.ru)
# Descr: Описание общих параметров, функций и процедур
# -------------------------------------------------------------------
# $Id $
# -------------------------------------------------------------------
# В файле определяются:
#
#  * текущие версии подсистем и форматов;
#  * общие параметры системы, значения которых должны быть
#    одинаковы на всех узлах;
#  * общие функции и процедуры, используемые в скриптах системы.
#
######################################################################

SYSTEM_VER="3.2"      # Версия системы

PACKET_VER_MAJOR=2    # Версия формата пакетов, создаваемых данной
PACKET_VER_MINOR=0    # версией системы. При смене номера MAJOR
                      # необходимо выполнить специальную процедуру
                      # обновления существующих пакетов

METADATA_VER_MAJOR=3  # Версия метаданных системы в базе данных.
METADATA_VER_MINOR=0  # При смене номера MAJOR необходимо обновить
                      # систему в БД

# ********************************************************************
# Общие параметры
# ********************************************************************

FOLDER_INBOX=inbox   # имя каталога для входящих сообщений (что пришло
                     # с узла)
FOLDER_OUTBOX=outbox # имя каталога для исходящих сообщений (что должно
                     # уйти на узел)

EXT_DELFILE=del      # расширение файлов, содержащих удаленные записи таблиц
EXT_DATFILE=dat      # расширение файлов, содержащих данные таблиц
EXT_ENCRYPT=enc      # расширение файлов, содержащих зашифрованные данные
EXT_SIGNATURE=sig    # расширение файлов, содержащих подписи
EXT_PUBKEY=key       # расширение файлов, содержащих открытый ключ
EXT_SECKEY=          # расширение файлов, содержащих закрытый ключ

FILENAME_PACKINFO="packet.info" # имя файла, в котором хранится информация
                                # о пакете (описания таблиц и т.д.)
FILENAME_NODES_CONF=nodes.conf  # имя файла конфигурации узлов
FILENAME_NODES_SEC=nodes.sec    # имя файла конфигурации безопасности
FILENAME_DATA=packet.data       # имя файла, содержащего данные пакета
FILENAME_DATA_ENC=$FILENAME_DATA.$EXT_ENCRYPT # имя файла, содержащего данные пакета
                                              # в зашифрованном виде

DATAFILE_SEPARATOR="_"    # разделитель между владельцем и именем таблицы
                          # в имени файла, содержащего данные таблицы
PACKET_PREFIX=pkt-        # префикс в имени файла-пакета
PACKET_NUMBER="%07u"      # формат номера пакета в имени файла-пакета

ARCH_STRUCTURE_DEFAULT='<T>/<M>/<N>' # структура каталогов архива по-умолчанию
                                     # (если в sync.conf не определен параметр
                                     # ARCHIVE_STRUCTURE).

SQL_MAX_TABLES_DEFAULT=20 # максимальное количество таблиц в блоке begin/end
                          # в SQL-скрипте подготовки пакета
                          # (если в sync.conf не определен параметр
                          # SQL_MAX_TABLES).

SQL_FIELD_SEPARATOR="---" # разделитель между полями для тех
                          # SQL-выражений, которые возвращают
                          # значения нескольких полей

# --------------------------------------------------------------------
# Названия файлов для кэширования

CACHE_PREPARE_BASE="cache.prepare" # основа в именах кэш-файлов для
                                   # подготовки пакетов для данного узла
CACHE_PREPARE_HASH="hash"          # расширение кэш-файла в котором хранится
                                   # хэш-значение описания таблиц
CACHE_PREPARE_INFO="info"          # расширение файла в котором хранится
                                   # кэшированное описание таблиц
CACHE_PREPARE_SQL="sql"            # расширение кэш-файла в котором хранится
                                   # кэшированный SQL-скрипт подготовки данных
                                   # для узла

CACHE_UPDATE_BASE="cache.update"   # основа в именах кэш-файлов для
                                   # обработки пакетов с данного узла
CACHE_UPDATE_HASH="hash"           # расширение кэш-файла в котором хранится
                                   # хэш-значение строки описания таблиц из
                                   # файла описания пакета
CACHE_UPDATE_SQL="sql"             # расширение кэш-файла в котором хранится
                                   # кэшированный SQL-скрипт обработки данных
                                   # с узла

# --------------------------------------------------------------------
# Названия параметров в файле описании пакета

PACKINFO_PACKET_VER_PACKET=packet_version  # версия формата пакета
PACKINFO_PACKET_VER_SYSTEM=system_version  # версия системы, создавшей пакет
PACKINFO_PACKET_SEC_LEVEL=packet_security_level # уровень безопасности пакета

PACKINFO_PACKET_NUMBER=packet_number       # номер пакета
PACKINFO_PACKET_PREV=packet_prev           # номер предыдущего пакета
PACKINFO_PACKET_FROM=packet_from           # от какого узла пакет
PACKINFO_PACKET_TO=packet_to               # какому узлу предназначен пакет

PACKINFO_TABLE_PKEYS=pkey_fields           # список ключевых полей
PACKINFO_TABLE_OTHER=other_fields          # список остальных полей
PACKINFO_TABLE_CREATE=create_clause        # описание всех полей, как
                                           # оно должно быть в выражении
                                           # create table

# Сигнатуры начала и конца общей секции описания пакета

GENERAL_SECTION_START='# === General packet description'
GENERAL_SECTION_STOP='# === End general packet description'

# Сигнатуры начала и конца секции описания всех таблиц

TABLES_SECTION_START='# === Description tables'
TABLES_SECTION_STOP='# === End tables description'

# Сигнатуры начала и конца секции описания таблицы.
# Внимание! Полное имя таблицы всегда должно быть
# написано заглавными буквами.

TABLE_SECTION_SEARCH='# --- Description table \([^.]*\)\.\([^.]*\)$'
TABLE_SECTION_START="# --- Description table <owner>.<table>"
TABLE_SECTION_STOP='# --- End description'

# --------------------------------------------------------------------
# Статусы выполненных действий в лог-файле

ST_OK=OK      # действие выполнено успешно
ST_ERR=ERR    # действие выполнилось с ошибкой
ST_WARN=WARN  # действие выполнилось с предупреждением
ST_INFO=INFO  # информационное сообщение

# --------------------------------------------------------------------
# Уровни безопасности пакетов

SEC_LEVEL0=0  # пакеты не подписываются и не шифруются
SEC_LEVEL1=1  # пакеты подписываются
SEC_LEVEL2=2  # пакеты подписываются и шифруются

# --------------------------------------------------------------------
# Тип уровня безопасности пакетов в конфигурационном файле nodes.sec

SEC_DIRECTION_IN=in   # для входящих пакетов
SEC_DIRECTION_OUT=out # для исходящих пакетов

# ********************************************************************
# Общие процедуры и функции
# ********************************************************************

# ********************************************************************
# pkt_number_by_filename - Вернуть номер пакета, указанного в имени
#                          файла-пакета
# ----------------------
# Параметры:
#   filename - имя файла-пакета

pkt_number_by_filename()
{
  typeset filename
  filename=$1
  echo $filename | sed -e "/^${PACKET_PREFIX}0*\([1234567890]*\).*/s//\1/"
}

# ********************************************************************
# pkt_filename_by_number - Вернуть имя файла-пакета по номеру пакета.
#                          ВНИМАНИЕ! Расширения не входят в имя файла.
# ----------------------
# Параметры:
#   number - номер пакета

pkt_filename_by_number()
{
  typeset filename
  typeset -i number

  let number=$1
  echo $PACKET_PREFIX`printf "$PACKET_NUMBER" $number`
}

# ********************************************************************
# arch_path - Вернуть путь к архиву пакетов
# ---------
# Параметры:
#   type  - тип пакета
#   node  - название узла
#   month - месяц создания пакета

arch_path()
{
  typeset type node month
  typeset str

  type=$1
  node=$2
  month=$3

  str="${ARCHIVE_STRUCTURE-$ARCH_STRUCTURE_DEFAULT}"
  str="$(replace "$str" "<T>" "$type")"
  str="$(replace "$str" "<N>" "$node")"
  str="$(replace "$str" "<M>" "$month")"

  echo ${PATH_ARCH}${str:+/$str}
}

# ********************************************************************
# table_owner - Вернуть владельца таблицы, как часть полного
#               названия таблицы (<владелец.<имя таблицы>)
# -----------
# Параметры:
#  table_fullname - полное название таблицы
#  separator      - необязательный параметр. Разделитель между
#                   владельцем и именем таблицы, если это не '.'

table_owner()
{
  typeset table_fullname str
  table_fullname=$1
  separator=$2

  if [ -z "$separator" ]
  then
    str=`expr $table_fullname : '\(.*\)\..*'`
  else
    str=`expr $table_fullname : '\([^'$separator']*\)\'$separator'.*'`
  fi
  if [ "$str" = "0" ]; then str=""; fi
  echo "$str"
}

# ********************************************************************
# table_name - Вернуть имя таблицы, как часть полного
#              названия таблицы (<владелец.<имя таблицы>)
# ----------
# Параметры:
#  table_fullname - полное название таблицы
#  separator      - необязательный параметр. Разделитель между
#                   владельцем и именем таблицы, если это не '.'

table_name()
{
  typeset table_fullname str
  table_fullname=$1
  separator=$2

  if [ -z "$separator" ]
  then
    str=`expr $table_fullname : '.*\.\(.*\)'`
  else
    str=`expr $table_fullname : '[^'$separator']*\'$separator'\(.*\)'`
  fi
  if [ "$str" = "0" ]; then str=""; fi
  echo "$str"
}

# ********************************************************************
# value_by_name - Вернуть значение переменной по ее имени
# -------------
#
# Параметры:
#   var - имя переменной

value_by_name()
{
  typeset var

  var="\$$1"
  eval printf "%s" \"$var\"
}

# ********************************************************************
# replace - Вернуть строку, в которой одна подстрока заменяется
# -------   другой подстрокой
#
# Параметры:
#   str -
#   old -
#   new -

replace()
{
  typeset str old new backslash

  str="$1"
  old="$2"
  new="$3"

  # Заменить в подстроках все вхождения символа '/' на комбинацию '\/'
  # для того, чтобы в подстроках можно было безопасно использовать
  # символ '/'. Иначе sed возвращает ошибку.

  backslash='\\'
  old=`echo "$old" | sed "s/\//$backslash\//g"`
  new=`echo "$new" | sed "s/\//$backslash\//g"`

  echo "$str" | sed "s/$old/$new/g"
}

# ********************************************************************
# lastsymbol - Вернуть последний символ строки
# ----------
#
# Параметры:
#   str -

lastsymbol()
{
  typeset str0 str1

  str0="$1"
  str1=${str0%?}
  echo "${str0##$str1}"
}

# ********************************************************************
# inlist - Проверить, входит ли слово в список
# ------
# Параметры:
#   word -
#   list -

inlist()
{
  typeset word list item

  word=$1
  list=$2

  for item in $list
  do
    if [ "$item" = "$word" ]
    then
      return
    fi
  done
  false
}

# ********************************************************************
# removelist - Удалить из списка подмножество элементов
# ----------
# Форма вызова: removelist <sublist> from <list>
#
# Параметры:
#   sublist - список элементов, которые необходимо убрать
#   list    - исходный список, из которого необходимо убрать элементы

removelist()
{
  typeset remove_list="$1"
  typeset source_list="$3"
  typeset result_list
  typeset item

  for item in $source_list
  do
    if inlist $item "$remove_list"
    then
      :
    else
      result_list="${result_list} ${item}"
    fi
  done
  echo "${result_list# }"
}

# ********************************************************************
# sortlist - Вернуть отсортированный список с убранными дублирующими
#            элементами
# --------
# Параметры:
#   list - список

sortlist()
{
  typeset list str item

  list="$1"

  str=""
  for item in $list
  do
    str="${str}\n${item}"
  done

  list_to_str "`echo ${str#\n} | sort -u -f`" " "
}

# ********************************************************************
# list_to_str - Вернуть строку, в которой все элементы списка
#               перечислены через разделитель. Дополнительно
#               каждый элемент списка может быть заключен в
#               рамки (например, взят в кавычки)
# -----------
# Параметры:
#   list         - список
#   separator    - разделитель
#   border_left  - (необязательно) левая рамка
#   border_right - (необязательно) правая рамка

list_to_str()
{
  typeset list separator str item

  list="$1"
  separator="$2"
  border_left="$3"
  border_right="$4"

  str=""
  for item in $list
  do
    str="${str}${separator}${border_left}${item}${border_right}"
  done

  # Вернуть итоговую строку с убранным первым лишним разделителем

  echo ${str#"$separator"}
}

# ********************************************************************
# list_to_str_ex - Вернуть строку в виде списка пар
#                  <элемент><префикс><элемент><разделитель>...
#                  Дополнительно каждый элемент списка может быть
#                  заключен в рамки (например, взят в кавычки)
# --------------
# Параметры:
#   list          - список
#   prefix        - префикс во второй части пары
#   separator     - разделитель
#   border_left1  - (необязательно) левая рамка у первого элемента в паре
#   border_right1 - (необязательно) правая рамка у первого элемента в паре
#   border_left2  - (необязательно) левая рамка у второго элемента в паре
#   border_right2 - (необязательно) правая рамка у второго элемента в паре

list_to_str_ex()
{
  typeset list prefix separator str item

  list="$1"
  prefix="$2"
  separator="$3"
  border_left1="$4"
  border_right1="$5"
  border_left2="$6"
  border_right2="$7"

  str=""
  for item in $list
  do
    str="${str}${separator}${border_left1}${item}${border_right1}${prefix}${border_left2}${item}${border_right2}"
  done

  # Вернуть итоговую строку с убранным первым лишним разделителем

  echo ${str#"$separator"}
}

# ********************************************************************
# logmsg - Записать сообщение в лог
# ------
# Параметры:
#   status  - статус сообщения
#   level   - уровень важности сообщения
#   display - показать или нет сообщение на консоли (1 - показать, 0 - нет)
#   func    - имя функции, с которой был вызов
#   msg     - сообщение

logmsg()
{
  typeset status msg
  typeset -i level display

  status="$1"
  let level=$2
  let display=$3
  func=$4
  msg="$5"

  if [ level -le $LOG_LEVEL -a "$msg" != "" ]
  then
    if [ ! -f $LOG_FILE ]
    then
      touch $LOG_FILE
      chown $REMOTE_USER:$REMOTE_USER $LOG_FILE
    fi
    echo `date +"%D %T"` "$status\t$SCRIPT_NAME($func): $msg" >> $LOG_FILE
  fi

  if [ $display -eq 1 ]; then echo "$msg"; fi
}

# ********************************************************************
# filesize - Вернуть размер файлов в байтах
# --------
# Параметры:
#   files - список файлов (может быть pattern)

filesize()
{
  typeset files
  typeset -i size total

  files="$1"

  let total=0
  for size in `ls -l $files 2> /dev/null | awk '{ print $5 }'`
  do
    let total=total+size
  done

  echo $total
}

# ********************************************************************
# upper - Вернуть входную строку в заглавном регистре
# -----
# Параметры:
#   str - строка
#
# Корректно работает только с буквами латинского алфавита.

upper()
{
  typeset str
  str="$1"
  echo "$str" | tr '[:lower:]' '[:upper:]'
}

# ********************************************************************
# compress_sql - Вернуть сжатый SQL-текст
# ------------
# Параметры:
#   sql  - SQL-текст

compress_sql()
{
  typeset sql

  sql="$1"

  # - убрать пробелы с начала строки
  # - заменить несколько пробелов одним
  # - убрать пустые строки (не работает)
  # - убрать комментарии
  # - убрать пробелы до и после знаков -=+/><,

  echo "$sql" | sed -e 's/^  *//g' \
              | sed -e 's/  */ /g' \
              | sed -e 's/^ *$//g' \
              | sed -e 's/--.*$//g' \
              | sed -e 's/ *\([-=+/><,]\) */\1/g'
}


# ********************************************************************
